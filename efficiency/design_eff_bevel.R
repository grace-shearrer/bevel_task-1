library(neuRosim)
library(fmri)
library(HH)

## ------------------------------------------------------------------------
###########REMEMBER TO CHANGE THE PATHS AT THE BOTTOM :D
############################################################
n.loop = 10

# THINGS TO CHANGE AKA GLOBALS #
delivery_time=5.0
cue_time=2.0
wait_time=1.0
rinse_time=2.0

iti_inital=cue_time+wait_time+rinse_time

water<-rep(0,20)#0 for the variable,  16 times
sweet<-rep(1,19) #1 for the variable, 16 times
unsweet<-rep(2,1)
all<-c(water, sweet, unsweet)
ntrials.total = 40 #total number of trials

dur = rep(5, ntrials.total)#length of stimulus of interest
#min and max jitter values possible
min=3
max=7

#iti_hard is all the time in a trial that is not of interest with the longest possible jitter (max)
iti_hard = rep(max+iti_inital, ntrials.total) #if using a random iti, you need to include this and the onsets into the loop, this is an estimation to get a set up
############################################################################

ons.all = cumsum(c(0,dur+iti_hard))
ons.all = ons.all[1:(ntrials.total)]
run.length = max(ons.all)+100 #added just a ton of end time so the random jitter doesn't mess me up
tr = 1
eff.size = 1
# Things I'd like to save
eff.val = rep(0, n.loop) #efficiency
#has to have the middle number the same as the matrix so number of stimuli + 1
desmats = array(0,c(run.length, 4,  n.loop)) #all the model data will get entered here, this is a 3x3x3 matrix of 0s length of the longest possible run time
#don't changes
ons.save = array(0,c(length(ons.all),3, n.loop)) #the onsets will go here, this is a blank 3x3x3 matrix length of the onsets

Sys.time()->start;
for (i in 1:n.loop){
  keep.looking = 1
  while (keep.looking == 1){#creating onsets
    trial.type = sample(all)
    length.repeats = rle(trial.type)$lengths 
    keep.looking = max(length.repeats) > 2 #the most efficient design would be a block, this prevents a huge block of one type
  }
#  dur = rep(5, ntrials.total)
  iti.uni = runif(1000, min, max) #randomly generate 1000 numbers between 1 and 7, mean is 4 this is the jitter
  iti = rep(iti_inital, ntrials.total) #iti that is not random, wait, cue, ect
  vr <- c(0) ### an empty vector for jitter
  jit<-c(0)
  for (j in 1:length(iti)) {#generating the jitter, randomly selecting a number from my distribution above
    jitter<-sample(iti.uni, 1)
    jit[j]<-round(jitter,0) #rounding jitter and adding it to a vector
    vr[j] <- iti[j]+jit[j] # adding it to my non-random interval and then vector
  }
  ons.all = cumsum(c(0,dur+vr)) #generating the onset time from the duration of the stimulus of interest and the jitter
  ons.all = ons.all[1:(ntrials.total)] #making a vector
#  run.length = max(ons.all)+100 #added just a ton of end time so the random jitter doesn't mess me up
  
  
  #taking the onsets and making them simulated activation
  water = specifydesign(ons.all[trial.type == 0], dur[trial.type == 0],
                       run.length, tr,
                       eff.size, conv = "double-gamma")
  sweet = specifydesign(ons.all[trial.type == 1], dur[trial.type == 1],
                        run.length, tr,
                        eff.size, conv = "double-gamma")
  unsweet = specifydesign(ons.all[trial.type == 2], dur[trial.type == 2],
                        run.length, tr,
                        eff.size, conv = "double-gamma")
  
  #save the simulated activation in a array (TRxContrast)
  des.mat = cbind(rep(1, length(sweet)), water,sweet,unsweet)
  # making the contrast this is sweet>unsweet
  con = c(0, 0, 1, -1) 
  #solving for the efficiency matrix
  eff.val[i] = 1/(t(con)%*%solve(t(des.mat)%*%des.mat)%*%con)
  ons.save[,,i]=c(ons.all,jit,trial.type)
  #creating an array adding des.mat to the efficiency matrix
  desmats[,,i] = des.mat
}
print(Sys.time()-start)

# Plot design matrices with best and worst efficiencies
par(mfrow = c(2, 1), mar = c(4, 3, 2, 1))
# finding the most eff matrix to plot all of the columns simulated activation for each TR
water.best = desmats[,2,which(eff.val == max(eff.val))]
sweet.best = desmats[,3,which(eff.val == max(eff.val))]
unsweet.best = desmats[,4,which(eff.val == max(eff.val))]

plot(sweet.best, type = 'l', lwd = 2, col = 'red', xlab = "TR", 
     ylab = '', ylim = c(min(c(sweet.best, water.best)), 1.3),
     main = "Highest Efficiency")
lines(water.best, lwd = 2, col = 'cyan')
lines(unsweet.best, lwd = 2, col = 'black')

water.worst = desmats[,2,which(eff.val == min(eff.val))]
sweet.worst = desmats[,3,which(eff.val == min(eff.val), arr.ind = TRUE)]
unsweet.worst = desmats[,4,which(eff.val == min(eff.val))]

plot(sweet.worst, type = 'l', lwd = 2, col = 'red', xlab = "TR", 
     ylab = '', ylim = c(min(c(sweet.worst, water.worst)), 1.3),
     main = "Lowest Efficiency")
lines(water.worst, lwd = 2, col = 'cyan')
lines(unsweet.worst, lwd = 2, col = 'black')

legend('topleft', c("water 0",  "sweet 1", "unsweet 2"), col = c("cyan", "red", "black"), lwd = c(2,1), bty = 'n')

#desmats TRxcontrast_activationxloops
#there are n.loops of matrices, with timepoint rows and contrast columns
#trying to back out which onsets are associated with the most efficient design
#order the efficiency, the last one (highest efficiency) is what you want
ord.eff = order(eff.val)
#most efficient
best = tail(ord.eff, 1)
ons.save[,,best]

#VIF check that your fake regressors aren't correlated
fake.data = rnorm(length(sweet))
mod.fake = lm(fake.data ~ unsweet.best + sweet.best)
vif(mod.fake)

#MAKE files##################CHANGE THESE TO A PATH YOU LIKE
write.table(ons.save[,,best][,1], "/Users/nibl/Documents/bevel_task/efficiency/onset_run01", row.names = F, col.names = F, sep="\t")
write.table(ons.save[,,best][,2], "/Users/nibl/Documents/bevel_task/efficiency/jitter_run01", row.names = F, col.names = F, sep="\t")
write.table(ons.save[,,best][,3], "/Users/nibl/Documents/bevel_task/efficiency/conds_run01", row.names = F, col.names = F, sep="\t")
